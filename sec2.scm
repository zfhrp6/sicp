(define (disp . args)
  (define (disp-i i)
    (display (list-ref args i)) (display " ")
    (if (< i (- (list-length args) 1))
         (disp-i (+ i 1))
         (newline)))
  (disp-i 0))

(define (list-length lst)
  (define (l-iter rest count)
    (if (null? rest)
        count
        (l-iter (cdr rest) (+ 1 count))))
  (l-iter lst 0))

(define (add-rat x y)
  (make-rat (+ (* (numer x) (denom y))
               (* (numer y) (denom x)))
            (* (denom x) (denom y))))

(define (sub-rat x y)
  (make-rat (- (* (numer x) (denom y))
               (* (numer y) (denom x)))
            (* (denom x) (denom y))))

(define (mul-rat x y)
  (make-rat (* (numer x) (numer y))
            (* (denom x) (denom y))))

(define (div-rat x y)
  (make-rat (* (numer x) (denom y))
            (* (denom x) (numer y))))

(define (equal-rat x y)
  (= (* (numer x) (denom y))
     (* (numer y) (denom x))))

(define (make-rat n d) (cons n d))

(define (numer x) (car x))

(define (denom x) (cdr x))

(define (print-rat x)
  (disp (numer x) "/" (denom x)))

(define one-half (make-rat 1 2))
(define one-third (make-rat 1 3))
(print-rat one-half)
(print-rat (add-rat one-half one-third))
(print-rat (mul-rat one-half one-third))
(print-rat (add-rat one-third one-third))
(print-rat (div-rat one-third one-half))

(define (make-rat n d)
  (let ((g (gcd n d)))
    (cons (/ n g) (/ d g))))
(print-rat one-half)
(print-rat (add-rat one-half one-third))
(print-rat (mul-rat one-half one-third))
(print-rat (add-rat one-third one-third))
(print-rat (div-rat one-third one-half))

; 問題2.1
(disp "*--- prob2.1")
(define (make-rat n d)
  (let ((g (gcd n d)))
    (if (< (* n d) 0)
        (cons (- (/ (abs n) g)) (/ (abs d) g))
        (cons (/ (abs n) g) (/ (abs d) g)))))

(define mtq (make-rat 3 -4))
(print-rat mtq)
(print-rat (add-rat mtq one-half))
(print-rat (mul-rat mtq mtq))

; 問題2.2
(disp "*--- prob2.2")
(define (print-point p)
  (disp "(" (x-point p) "," (y-point p) ")"))
(define (make-segment sp ep)
  (cons sp ep))
(define (start-segment seg)
  (car seg))
(define (end-segment seg)
  (cdr seg))
(define (make-point x y)
  (cons x y))
(define (x-point p)
  (car p))
(define (y-point p)
  (cdr p))
(define (midpoint-segment seg)
  (make-point (/ (+ (x-point (start-segment seg)) (x-point (end-segment seg))) 2)
              (/ (+ (y-point (start-segment seg)) (y-point (end-segment seg))) 2)))
(define origin (make-point 0 0))
(define tttt (make-point 33 33))
(define mipl (make-point 99 -0.4))
(define seg1 (make-segment tttt mipl))
(define seg2 (make-segment origin tttt))
(print-point (midpoint-segment seg2))
(print-point (midpoint-segment seg1))

; 問題2.3
(disp "*--- prob2.3")
(define (print-rect rect)
  (print-point (car rect))
  (print-point (cdr rect)))
(define (make-rectangle p1 p2)
  (cons p1 p2))
(define (height rect)
  (abs (- (y-point (car rect)) (y-point (cdr rect)))))
(define (width rect)
  (abs (- (x-point (car rect)) (x-point (cdr rect)))))
(define (area rect)
  (* (height rect) (width rect)))
(define (perimeter rect)
  (* 2 (+ (height rect) (width rect))))

(define rect1 (make-rectangle origin tttt))
(define rect2 (make-rectangle (make-point 1 1) origin))
(print-rect rect1)
(print-rect rect2)
(disp "area" (area rect1) (area rect2))

(define (cons2 x y)
  (define (dispatch m)
    (cond ((= m 0) x)
          ((= m 1) y)
          (else (error "Argument not 0 or 1 --CONS" m))))
  dispatch)
(define (car2 z) (z 0))
(define (cdr2 z) (z 1))

(define (cons3 x y)
  (lambda (m) (m x y)))
(define (car3 z)
  (z (lambda (p q) p)))
(define (cdr3 z)
  (z (lambda (p q) q)))
(disp (cdr3 (cons3 1 2)))

; 問題2.5
(define (cons4 a b) (* (expt 2 a) (expt 3 b)))
(define (car4 pr) (div_count pr 2))
(define (cdr4 pr) (div_count pr 3))
(define (div_count n a)
  (define (div-iter n a cnt)
    (cond ((= n 0) cnt)
          ((= 0 (remainder n a)) (div-iter (/ n a) a (+ 1 cnt)))
          (else cnt)))
  (div-iter n a 0))
(define abpr1 (cons4 3 4))
(define abpr2 (cons4 1231 23491))
(disp (car4 abpr2) (cdr4 abpr2))

; 問題2.6
(define zero (lambda (f) (lambda (x) x)))
(define (add-1 n)
  (lambda (f) (lambda (x) (f ((n f) x)))))
(disp (add-1 zero))
(define one (lambda (f) (lambda (x) (f x))))
(define two (lambda (f) (lambda (x) (f (f x)))))
(define plus 8)
(define inc (lambda (x) (+ 1 x)))
(disp ((zero inc) 0))
(define (add-church m n)
  (lambda (f) (lambda (x) ((m f) ((n f) x)))))
(disp (((add-church one two) inc) 1))
